name: Deploy to Production Server

on:
  push:
    branches:
      - main # PRODUCCION se despliega desde main
  workflow_dispatch: # Permite ejecutar manualmente desde GitHub UI

env:
  DEPLOY_PATH: C:\deploy\ComedorProduccion
  COMPOSE_FILE: docker-compose.yml

jobs:
  deploy:
    name: Build and Deploy to Production Server
    runs-on: [self-hosted, Windows, X64, production, comedor] # Ejecuta solo en runners Windows con label 'production' y 'comedor'
    
    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4
        with:
          clean: false
      
      - name: 📂 Create deploy directory
        run: |
          if (-not (Test-Path "$env:DEPLOY_PATH")) {
            New-Item -Path "$env:DEPLOY_PATH" -ItemType Directory -Force
            Write-Host "OK: Directorio de despliegue creado"
          }
        shell: powershell
      
      - name: 📋 Verify .env exists
        run: |
          $envPath = Join-Path $env:DEPLOY_PATH ".env"
          if (-not (Test-Path $envPath)) {
            Write-Host "ERROR: Archivo .env no encontrado en $envPath"
            Write-Host "ERROR: Crear archivo .env con las credenciales antes de continuar"
            exit 1
          }
          Write-Host "OK: Archivo .env encontrado"
        shell: powershell
      
      - name:  Deploy files to production server
        run: |
          Write-Host "INFO: Desplegando archivos a PRODUCCION..."
          
          # Copiar todos los archivos excepto .env y logs
          $excludeItems = @('.env', 'nginx/logs', '.git', 'README.md')
          
          Get-ChildItem -Path '.' -Recurse | ForEach-Object {
            $shouldExclude = $false
            foreach ($exclude in $excludeItems) {
              if ($_.FullName -like '*$exclude*') {
                $shouldExclude = $true
                break
              }
            }
            
            if (-not $shouldExclude -and -not $_.PSIsContainer) {
              $relativePath = $_.FullName.Substring((Get-Location).Path.Length + 1)
              $destPath = Join-Path $env:DEPLOY_PATH $relativePath
              $destDir = Split-Path $destPath -Parent
              
              if (-not (Test-Path $destDir)) {
                New-Item -Path $destDir -ItemType Directory -Force | Out-Null
              }
              
              Copy-Item -Path $_.FullName -Destination $destPath -Force
            }
          }
          
          Write-Host "OK: Archivos desplegados en" $env:DEPLOY_PATH
        shell: powershell
      
      - name: 🐳 Verify Docker installation
        run: |
          try {
            $dockerVersion = docker --version
            Write-Host "OK: Docker instalado: $dockerVersion"
            
            $composeVersion = docker compose version
            Write-Host "OK: Docker Compose instalado: $composeVersion"
          } catch {
            Write-Host "ERROR: Docker no está instalado o no está en el PATH"
            exit 1
          }
        shell: powershell
      
      - name: 🛑 Stop current containers
        run: |
          cd $env:DEPLOY_PATH
          
          $composeFile = Join-Path $env:DEPLOY_PATH $env:COMPOSE_FILE
          if (Test-Path $composeFile) {
            Write-Host "INFO: Deteniendo contenedores de PRODUCCION..."
            docker compose -f $env:COMPOSE_FILE down
            Write-Host "OK: Contenedores detenidos"
          } else {
            Write-Host "INFO: No hay contenedores corriendo"
          }
        shell: powershell
        continue-on-error: true
      
      - name: 🏗️ Build Docker images
        run: |
          cd $env:DEPLOY_PATH
          
          Write-Host "INFO: Construyendo imagenes Docker para PRODUCCION..."
          Write-Host "INFO: Directorio: $(Get-Location)"
          Write-Host "INFO: Archivo compose: $env:COMPOSE_FILE"
          
          docker compose -f $env:COMPOSE_FILE build
          
          if ($LASTEXITCODE -eq 0) {
            Write-Host "OK: Imagenes construidas exitosamente"
          } else {
            Write-Host "ERROR: Error al construir imagenes (Exit code: $LASTEXITCODE)"
            exit 1
          }
        shell: powershell
      
      - name: 🚀 Start containers
        run: |
          cd $env:DEPLOY_PATH
          
          Write-Host "INFO: Iniciando contenedores de PRODUCCION..."
          docker compose -f $env:COMPOSE_FILE up -d
          
          if ($LASTEXITCODE -eq 0) {
            Write-Host "OK: Contenedores iniciados exitosamente"
          } else {
            Write-Host "ERROR: Error al iniciar contenedores"
            exit 1
          }
        shell: powershell
      
      - name: 🔍 Verify containers status
        run: |
          cd $env:DEPLOY_PATH
          Write-Host "INFO: Verificando estado de contenedores..."
          Start-Sleep -Seconds 10
          docker compose -f $env:COMPOSE_FILE ps
          Write-Host "OK: Contenedores verificados"
        shell: powershell
      
      - name: 🏥 Health check
        run: |
          Write-Host "INFO: Verificando salud del servidor de PRODUCCION..."
          
          # Leer el puerto del archivo .env
          $envContent = Get-Content "$env:DEPLOY_PATH\.env"
          $port = 80
          foreach ($line in $envContent) {
            if ($line -match 'HTTP_PORT=(\d+)') {
              $port = $matches[1]
              break
            }
          }
          
          Write-Host "INFO: Esperando 15 segundos para que Nginx este listo..."
          Start-Sleep -Seconds 15
          
          try {
            $response = Invoke-WebRequest -Uri "http://localhost:$port" -UseBasicParsing -TimeoutSec 10 -ErrorAction Stop
            Write-Host "OK: Servidor respondiendo en puerto $port - Status: $($response.StatusCode)"
          } catch {
            Write-Host "WARNING: No se pudo verificar HTTP en puerto $port"
            Write-Host "WARNING: Esto puede ser normal si la app requiere configuracion adicional"
            Write-Host "INFO: Los contenedores estan corriendo correctamente"
          }
        shell: powershell
        continue-on-error: true
      
      - name: 🧹 Clean old images
        run: |
          Write-Host "INFO: Limpiando imagenes antiguas..."
          docker image prune -f
          Write-Host "OK: imagenes antiguas eliminadas"
        shell: powershell
        continue-on-error: true
      
      - name: 📊 Deployment summary
        run: |
          cd $env:DEPLOY_PATH
          
          # Leer el puerto del archivo .env
          $envContent = Get-Content "$env:DEPLOY_PATH\.env"
          $port = 80
          foreach ($line in $envContent) {
            if ($line -match 'HTTP_PORT=(\d+)') {
              $port = $matches[1]
              break
            }
          }
          
          Write-Host ""
          Write-Host "============================================================="
          Write-Host "  DESPLIEGUE EN PRODUCCION COMPLETADO EXITOSAMENTE"
          Write-Host "============================================================="
          Write-Host ""
          Write-Host "Ubicacion: $env:DEPLOY_PATH"
          Write-Host "URL: http://localhost:$port"
          Write-Host "Fecha: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"
          Write-Host "Commit: $env:GITHUB_SHA"
          Write-Host "Autor: $env:GITHUB_ACTOR"
          Write-Host "Branch: main (PRODUCCION)"
          Write-Host ""
          Write-Host "Contenedores corriendo:"
          docker compose -f $env:COMPOSE_FILE ps
          Write-Host ""
          Write-Host "OK: Servidor de PRODUCCION actualizado y corriendo"
          Write-Host ""
        shell: powershell
      
      - name: 📧 Notify on failure
        if: failure()
        run: |
          Write-Host ""
          Write-Host "============================================================="
          Write-Host "       DESPLIEGUE EN PRODUCCION FALLO"
          Write-Host "============================================================="
          Write-Host ""
          Write-Host "INFO: Revisa los logs del workflow en GitHub Actions"
          Write-Host "INFO: Revisa los logs de contenedores con:"
          Write-Host "       cd $env:DEPLOY_PATH"
          Write-Host "       docker compose -f $env:COMPOSE_FILE logs"
          Write-Host ""
        shell: powershell
